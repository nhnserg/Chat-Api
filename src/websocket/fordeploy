import { WebSocketServer } from 'ws';
import { WebSocketService } from '../websocket/webSocket.service.js';
import { authenticate } from '../middleware/authenticate.js';

export class WebSocketManager {
  constructor(server) {
    this.wss = new WebSocketServer({ server });
    this.wsService = new WebSocketService();
    this.setupWebSocket();
  }

  setupWebSocket() {
    this.wss.on('connection', async (ws, req) => {
      try {
        const token = req.headers['sec-websocket-protocol'];
        if (!token) {
          ws.send(
            JSON.stringify({ type: 'error', error: 'Authentication required' })
          );
          ws.close();
          return;
        }

        const user = await authenticate(token);
        console.log(`âœ… ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ${user.username} Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½`);

        ws.send(JSON.stringify({ type: 'success', message: 'Connected' }));

        ws.on('message', async data => {
          try {
            const message = JSON.parse(data);

            switch (message.type) {
              case 'join':
                this.handleJoin(ws, message, user);
                break;
              case 'message':
                await this.handleMessage(ws, message, user);
                break;
              case 'privateMessage':
                await this.handlePrivateMessage(ws, message, user);
                break;
              case 'typing':
                this.handleTyping(ws, message, user);
                break;
              default:
                console.warn('âš  ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ñ‹Ð¹ Ñ‚Ð¸Ð¿ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ:', message.type);
            }
          } catch (error) {
            console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ:', error);
            ws.send(
              JSON.stringify({
                type: 'error',
                error: 'Invalid message format',
              })
            );
          }
        });

        ws.on('close', () => {
          const client = this.wsService.getClientInfo(ws);
          if (!client) return;

          console.log(
            `âŒ ÐšÐ»Ð¸ÐµÐ½Ñ‚ ${client.username} Ð¿Ð¾ÐºÐ¸Ð½ÑƒÐ» Ñ‡Ð°Ñ‚ ${client.roomId}`
          );

          this.broadcast(client.roomId, {
            type: 'userLeft',
            username: client.username,
            timestamp: new Date(),
          });

          this.wsService.removeClient(ws);
        });
      } catch (error) {
        console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð°ÑƒÑ‚ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ð¸:', error);
        ws.send(JSON.stringify({ type: 'error', error: 'Invalid token' }));
        ws.close();
      }
    });
  }

  handleJoin(ws, message) {
    const roomId = message.roomId || message.room;
    if (!roomId) {
      console.error('â›” ÐžÑˆÐ¸Ð±ÐºÐ°: ÐºÐ¾Ð¼Ð½Ð°Ñ‚Ð° Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½Ð° Ð¿Ñ€Ð¸ Ð²Ñ…Ð¾Ð´Ðµ:', message);
      return;
    }

    this.wsService.addClient(ws, message.username, roomId);
    console.log(`ðŸ‘¤ ${message.username} Ð¿Ñ€Ð¸ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸Ð»ÑÑ Ðº ${roomId}`);

    this.broadcast(
      message.roomId,
      {
        type: 'userJoined',
        username: message.username,
        timestamp: new Date(),
      },
      ws
    );
  }

  async handleMessage(ws, message, user) {
    const newMessage = await this.wsService.handleMessage(user, message);

    if (!newMessage) {
      console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ°: ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð½Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¾', message);
      return;
    }

    this.broadcast(
      message.roomId,
      {
        type: 'message',
        messageId: newMessage._id,
        username: user.name,
        content: message.content,
        timestamp: new Date(),
      },
      ws
    );
  }

  async handlePrivateMessage(ws, message) {
    const privateMessage = await this.wsService.handlePrivateMessage(message);

    if (!privateMessage) {
      console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ°: Ð»Ð¸Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð½Ðµ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¾', message);
      return;
    }

    const delivered = this.sendPrivateMessage(message.recipient, {
      type: 'privateMessage',
      messageId: privateMessage._id,
      sender: message.username,
      content: message.content,
      timestamp: new Date(),
    });

    ws.send(
      JSON.stringify({
        type: 'privateMessageStatus',
        messageId: privateMessage._id,
        delivered: delivered,
        timestamp: new Date(),
      })
    );
  }

  handleTyping(ws, message) {
    this.broadcast(
      message.roomId,
      {
        type: 'typing',
        username: message.username,
        isTyping: message.isTyping,
      },
      ws
    );
  }

  broadcast(roomId, message, sender) {
    this.wss.clients.forEach(client => {
      const clientInfo = this.wsService.getClientInfo(client);
      if (clientInfo && clientInfo.roomId === roomId && client !== sender) {
        client.send(JSON.stringify(message));
      }
    });
  }

  sendPrivateMessage(username, message) {
    for (const [client, data] of this.wsService.clients) {
      if (data.username === username) {
        client.send(JSON.stringify(message));
        return true;
      }
    }
    return false;
  }
}
