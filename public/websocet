import { WebSocketServer } from 'ws';
import { WebSocketService } from '../websocket/webSocket.service.js';
import jwt from 'jsonwebtoken';
import { User } from '../user/user.model.js';
import { HttpError } from '../helpers/HttpError.js';
import dotenvConfig from '../dotenvConfig.js';

const { KEY_ACCESS } = dotenvConfig;

export class WebSocketManager {
  constructor(server) {
    this.wss = new WebSocketServer({ server });
    this.wsService = new WebSocketService();
    this.setupWebSocket();
  }

  setupWebSocket() {
    this.wss.on('connection', (ws, req) => {
      console.log('âœ… ÐÐ¾Ð²Ñ‹Ð¹ ÐºÐ»Ð¸ÐµÐ½Ñ‚ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ð»ÑÑ');

      // Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ñ‚Ð¾ÐºÐµÐ½ Ð¸Ð· Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ°
      const token = req.headers['authorization']?.split(' ')[1];
      if (!token) {
        ws.close(1008, 'Unauthorized: No token provided');
        return;
      }

      let user;
      try {
        user = jwt.verify(token, KEY_ACCESS);
      } catch (error) {
        ws.close(1008, 'Unauthorized: Invalid token');
        return;
      }

      // ÐŸÑ€Ð¸Ð²ÑÐ·Ñ‹Ð²Ð°ÐµÐ¼ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ðº ÑÐ¾ÐºÐµÑ‚Ñƒ
      ws.user = user;

      ws.on('message', async data => {
        try {
          const message = JSON.parse(data);

          switch (message.type) {
            case 'join':
              this.handleJoin(ws, message);
              break;
            case 'message':
              await this.handleMessage(ws, message);
              break;
            case 'privateMessage':
              await this.handlePrivateMessage(ws, message);
              break;
            case 'typing':
              this.handleTyping(ws, message);
              break;
            default:
              console.warn('âš  ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ñ‹Ð¹ Ñ‚Ð¸Ð¿ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ:', message.type);
          }
        } catch (error) {
          console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ:', error);
          ws.send(
            JSON.stringify({ type: 'error', error: 'Invalid message format' })
          );
        }
      });

      ws.on('close', () => {
        const client = this.wsService.getClientInfo(ws);
        if (!client) return;

        console.log(`âŒ ÐšÐ»Ð¸ÐµÐ½Ñ‚ ${client.name} Ð¿Ð¾ÐºÐ¸Ð½ÑƒÐ» Ñ‡Ð°Ñ‚ ${client.roomId}`);

        this.broadcast(client.roomId, {
          type: 'userLeft',
          name: client.name,
          timestamp: new Date(),
        });

        this.wsService.removeClient(ws);
      });
    });
  }

  handleJoin(ws, message) {
    const roomId = message.roomId || message.room;
    if (!roomId) {
      console.error('â›” ÐžÑˆÐ¸Ð±ÐºÐ°: ÐºÐ¾Ð¼Ð½Ð°Ñ‚Ð° Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½Ð° Ð¿Ñ€Ð¸ Ð²Ñ…Ð¾Ð´Ðµ:', message);
      return;
    }

    this.wsService.addClient(ws, message.name, roomId);
    console.log(`ðŸ‘¤ ${message.name} Ð¿Ñ€Ð¸ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸Ð»ÑÑ Ðº ${roomId}`);

    this.broadcast(
      message.roomId,
      {
        type: 'userJoined',
        name: message.name,
        timestamp: new Date(),
      },
      ws
    );
  }

  async handleMessage(ws, message) {
    const newMessage = await this.wsService.handleMessage(message); // Ð£Ð±Ñ€Ð°Ð»Ð¸ user

    if (!newMessage) {
      console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ°: ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð½Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¾', message);
      return;
    }

    this.broadcast(
      message.roomId,
      {
        type: 'message',
        messageId: newMessage._id,
        name: message.name, // Ð’Ð·ÑÐ»Ð¸ Ð¸Ð· message
        content: message.content,
        timestamp: new Date(),
      },
      ws
    );
  }

  async handlePrivateMessage(ws, message) {
    const privateMessage = await this.wsService.handlePrivateMessage(message);

    if (!privateMessage) {
      console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ°: Ð»Ð¸Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð½Ðµ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¾', message);
      return;
    }

    const delivered = this.sendPrivateMessage(message.recipient, {
      type: 'privateMessage',
      messageId: privateMessage._id,
      sender: message.name,
      content: message.content,
      timestamp: new Date(),
    });

    ws.send(
      JSON.stringify({
        type: 'privateMessageStatus',
        messageId: privateMessage._id,
        delivered: delivered,
        timestamp: new Date(),
      })
    );
  }

  handleTyping(ws, message) {
    this.broadcast(
      message.roomId,
      {
        type: 'typing',
        name: message.name,
        isTyping: message.isTyping,
      },
      ws
    );
  }

  broadcast(roomId, message, sender) {
    this.wss.clients.forEach(client => {
      const clientInfo = this.wsService.getClientInfo(client);
      if (clientInfo && clientInfo.roomId === roomId && client !== sender) {
        client.send(JSON.stringify(message));
      }
    });
  }

  sendPrivateMessage(name, message) {
    for (const [client, data] of this.wsService.clients) {
      if (data.name === name) {
        client.send(JSON.stringify(message));
        return true;
      }
    }
    return false;
  }
}
